# Building Applications with GitHub Copilot Agent Mode

## Overview

GitHub Copilot Agent Mode represents a major advancement in AI-assisted software development. Unlike traditional coding assistants that provide simple autocomplete-style suggestions, Agent Mode functions as an autonomous peer programmer that helps developers accomplish more with less effort. This module teaches you how to build applications using GitHub Copilot Agent Mode within a GitHub Codespace and the VS Code IDE, exploring how to effectively prompt Agent Mode to autonomously create new applications, use documentation files to clearly guide its behavior, and harness its powerful iteration capabilities.

**Module Duration**: 36 minutes  
**Level**: Intermediate

## Learning Objectives

By the end of this module, you will be able to:

- Understand how to develop with VS Code IDE in a GitHub Codespace
- Prompt GitHub Copilot agent mode to create an application
- Leverage documentation files to instruct GitHub Copilot agent mode
- Understand how GitHub Copilot agent mode iterates over a code base to:
  - Fix errors
  - Refactor code
  - Develop new features

## Prerequisites

- A GitHub account and a fundamental understanding of GitHub Copilot
- Basic familiarity with development workflows

## What is GitHub Copilot Agent Mode?

Agent Mode doesn't just suggest code—it understands your entire workspace, processes tasks dynamically, and iterates on its own output to improve solutions. With Agent Mode, GitHub Copilot can:

- Create applications from scratch
- Refactor code across multiple files
- Write and run tests
- Migrate legacy code to modern frameworks
- Generate documentation
- Integrate new libraries
- Answer complex questions about a codebase

### How GitHub Copilot Agent Mode Works

One of the most powerful aspects of Agent Mode is its ability to analyze an entire codebase and determine relevant files and dependencies before making changes. When given a task, it:

1. **Determines** the relevant files and dependencies before making edits
2. **Suggests and executes** code changes while ensuring they align with the project structure
3. **Runs terminal commands** as needed, such as compiling code, installing dependencies, and running tests
4. **Monitors and refines** its output, iterating multiple times to remediate issues and improve accuracy

This iterative process enables Copilot to function as a truly collaborative AI, continuously improving its own suggestions while keeping the developer in full control.

### Interacting with GitHub Copilot

GitHub Copilot offers multiple ways to assist you:

- **Inline Suggestions**: Advanced autocomplete capabilities offering real-time code completions as you type
- **Copilot Chat**: Dedicated chat panel for coding-related questions, tailored to your project context
- **Copilot Edits**: Apply changes across multiple files for large-scale updates
- **Agent Mode**: Orchestrates development tasks dynamically, iterating to improve accuracy

## Exploring Autonomous Development Assistance

### Autonomous Operation

Copilot Agent Mode independently analyzes coding requests, dynamically identifies relevant files, determines appropriate terminal commands, and implements comprehensive solutions without explicit step-by-step instructions.

**Example**: Creating a new REST API endpoint

Agent Mode autonomously:
- Creates API routes (`routes/api.js`)
- Updates main application (`app.js`)
- Installs necessary dependencies (`npm install express`)
- Generates test cases (`tests/api.test.js`)

### Handling Complex, Multi-Step Tasks

Agent Mode excels in breaking down complex tasks into structured, sequential actions.

**Multi-step task example**: Integrate a new database into an existing application

Agent Mode performs autonomously:
1. Updates dependencies (`npm install mongoose`)
2. Generates database connection logic (`database.js`)
3. Modifies environment configuration (`.env`)
4. Creates data model definitions (`models/userModel.js`)
5. Writes automated tests (`tests/userModel.test.js`)

### Multi-Step Orchestration Workflows

Agent Mode coordinates complex development processes through intelligent orchestration:

**Draft-Review-Accept Workflow Example**: Adding user authentication

- **Draft phase**: Agent Mode generates authentication middleware, user login routes, password hashing utilities, and frontend login form
- **Review phase**: Agent Mode evaluates its own draft, identifying security vulnerabilities, suggesting error handling improvements, recommending validation for edge cases, and proposing unit tests
- **Accept phase**: Developer reviews refined, PR-ready implementation with built-in security best practices

> **Note**: Each handoff in Agent Mode consumes ~1 PRU. A 2-step draft–review sequence typically uses 2–3 PRUs.

### Automated Foundation Building

Agent Mode handles repetitive setup tasks, allowing developers to focus on core business logic:

**Scenario**: Setting up a new microservice

Agent Mode automatically generates:
- Project structure with standard directories (`src/`, `tests/`, `config/`)
- Package configuration (`package.json`, `Dockerfile`, `.gitignore`)
- Testing framework setup (`jest.config.js`, sample test files)
- CI/CD pipeline configuration (`.github/workflows/test.yml`)
- Environment configuration templates (`.env.example`, `config/default.js`)
- Basic monitoring and logging setup (`utils/logger.js`, health check endpoints)

### Advanced Reasoning Capabilities

For complex scenarios requiring deeper analysis, Agent Mode can leverage premium reasoning:

- **Architectural decision analysis**: Evaluate trade-offs between different implementation approaches
- **Cross-system impact assessment**: Understand how changes affect multiple components
- **Performance optimization strategies**: Identify bottlenecks and suggest improvements
- **Security vulnerability analysis**: Detect and propose fixes for potential security issues

> **Note**: Premium reasoning using advanced models provides richer context but often doubles PRU consumption (~4+ PRUs per request vs. ~2 with standard model).

### Using Intelligent Tools and Context Awareness

Agent Mode uses context from your project's files, dependencies, and prior actions to offer accurate and contextually relevant outputs.

**Context-aware deployment example**: Deploying a React application

Agent Mode intelligently:
- Recognizes project type via `package.json`
- Runs suitable build scripts (`npm run build`)
- Prepares deployment scripts aligned with existing workflow contexts

### Iterative Improvement and Self-Healing

Agent Mode autonomously detects, corrects, and revalidates its solutions.

**Self-healing example**: Generated unit tests initially fail due to a syntax error

Agent Mode autonomously:
1. Detects the cause of failure
2. Applies a corrective solution
3. Re-runs the tests until they pass successfully

### Ensuring User Control and Oversight

Every action proposed by Agent Mode can be reviewed, adjusted, or reverted at any time:

**Developer control example**: Agent Mode proposes extensive changes to authentication logic

Developer can:
- Review summarized changes in a pull request
- Request specific modifications or revisions
- Easily undo or adjust changes as required

### Limitations and Practical Considerations

Agent Mode may struggle with:
- Specialized domain logic
- Nuanced business rules
- Missing critical project context

**Limitation example**: Poorly documented custom business logic may result in less accurate or incomplete solutions, requiring increased manual review.

## Assessment Questions

1. What distinguishes GitHub Copilot Agent Mode from traditional coding assistants?
   - A) It only provides inline code suggestions
   - B) It autonomously handles multi-step tasks and iterates on its own outputs
   - C) It requires step-by-step instructions for every action
   - D) It cannot run terminal commands

2. Which interaction method allows Copilot to orchestrate development tasks dynamically?
   - A) Inline Suggestions
   - B) Copilot Chat
   - C) Copilot Edits
   - D) Agent Mode

3. When creating a REST API endpoint, which files would Agent Mode autonomously create?
   - A) Only the route file
   - B) Route file and main application update only
   - C) Routes, main application updates, dependencies, and test files
   - D) Documentation only

4. In a database integration task, what is the first step Agent Mode typically performs?
   - A) Writes test cases
   - B) Updates dependencies
   - C) Modifies environment configuration
   - D) Creates data models

5. What does the "Draft" phase in the Draft-Review-Accept workflow typically produce?
   - A) Final production code
   - B) Initial implementation of authentication components
   - C) Security audit reports
   - D) User documentation

6. How many PRUs does a typical 2-step draft-review sequence consume?
   - A) 1 PRU
   - B) 2-3 PRUs
   - C) 5-7 PRUs
   - D) 10+ PRUs

7. When setting up a new microservice, which configuration does Agent Mode NOT automatically generate?
   - A) Project structure directories
   - B) CI/CD pipeline configuration
   - C) Custom business logic implementation
   - D) Testing framework setup

8. What type of analysis does advanced reasoning in Agent Mode provide?
   - A) Only syntax checking
   - B) Architectural decision analysis and cross-system impact assessment
   - C) Basic autocomplete suggestions
   - D) File renaming operations

9. How much more PRU consumption does premium reasoning typically require compared to standard model?
   - A) The same amount
   - B) 50% more
   - C) Approximately double (~4+ vs ~2 PRUs)
   - D) Ten times more

10. In context-aware deployment, how does Agent Mode recognize a React application?
    - A) By file extensions
    - B) By analyzing package.json
    - C) By asking the developer
    - D) By random selection

11. What happens when Agent Mode generates code with syntax errors?
    - A) It stops and requires manual intervention
    - B) It ignores the errors
    - C) It autonomously detects, corrects, and re-runs tests
    - D) It deletes the code

12. What level of control does a developer have over Agent Mode's proposals?
    - A) No control—changes are automatic
    - B) Full control—can review, adjust, or revert at any time
    - C) Limited to approving or rejecting only
    - D) Control only after deployment

13. What type of logic might Agent Mode struggle with?
    - A) Standard CRUD operations
    - B) Specialized domain logic and nuanced business rules
    - C) File I/O operations
    - D) Basic HTTP requests

14. Which of the following is NOT a way to interact with GitHub Copilot?
    - A) Inline Suggestions
    - B) Copilot Chat
    - C) Voice Commands
    - D) Agent Mode

15. What makes Agent Mode's iteration process different from traditional AI code completion?
    - A) It provides static suggestions only
    - B) It works dynamically, processing requests in iterative cycles
    - C) It requires manual approval for each step
    - D) It doesn't suggest code changes

16. During the "Review" phase of authentication implementation, what does Agent Mode identify?
    - A) Only code formatting issues
    - B) Security vulnerabilities, error handling improvements, and validation needs
    - C) Developer performance metrics
    - D) Marketing requirements

17. What is included in the automated foundation building for a microservice?
    - A) Only source code files
    - B) Complete project structure, configs, tests, CI/CD, and monitoring setup
    - C) Database schemas only
    - D) User interface designs

18. How does Agent Mode ensure modifications align with project structure?
    - A) By ignoring existing code
    - B) By analyzing the entire codebase and determining relevant files before making changes
    - C) By asking the user for every decision
    - D) By using random templates

19. What happens if critical project context is missing for Agent Mode?
    - A) Agent Mode invents the context
    - B) Solutions may be less accurate or incomplete, requiring more manual review
    - C) Agent Mode refuses to work
    - D) The project is deleted

20. What is the primary benefit of Agent Mode's self-healing capability?
    - A) It eliminates all bugs permanently
    - B) It significantly minimizes manual debugging effort by autonomously fixing and revalidating
    - C) It makes code run faster
    - D) It reduces file sizes

21. When Agent Mode runs terminal commands, what types of operations can it perform?
    - A) Only file operations
    - B) Compiling code, installing dependencies, and running tests
    - C) System administration tasks only
    - D) Network configuration only

22. What tool does GitHub Copilot use to help derive context from code and comments?
    - A) GitHub Actions
    - B) OpenAI Codex
    - C) Docker
    - D) Jenkins

23. In the context of a React deployment scenario, what does Agent Mode prepare?
    - A) Only the build command
    - B) Suitable build scripts and deployment scripts aligned with existing workflows
    - C) Marketing materials
    - D) User manuals

24. What is the recommended approach when Agent Mode provides poorly documented custom business logic?
    - A) Accept it without review
    - B) Increase manual review and provide clearer context
    - C) Disable Agent Mode permanently
    - D) Ignore the outputs

25. Which statement best describes the relationship between developer and Agent Mode?
    - A) Agent Mode replaces the developer entirely
    - B) Agent Mode is an intelligent, proactive collaborator that adapts to developer workflow
    - C) Agent Mode only works offline
    - D) Agent Mode requires constant supervision for every character typed

## Answer Key

1. **B** - It autonomously handles multi-step tasks and iterates on its own outputs
2. **D** - Agent Mode
3. **C** - Routes, main application updates, dependencies, and test files
4. **B** - Updates dependencies
5. **B** - Initial implementation of authentication components
6. **B** - 2-3 PRUs
7. **C** - Custom business logic implementation
8. **B** - Architectural decision analysis and cross-system impact assessment
9. **C** - Approximately double (~4+ vs ~2 PRUs)
10. **B** - By analyzing package.json
11. **C** - It autonomously detects, corrects, and re-runs tests
12. **B** - Full control—can review, adjust, or revert at any time
13. **B** - Specialized domain logic and nuanced business rules
14. **C** - Voice Commands
15. **B** - It works dynamically, processing requests in iterative cycles
16. **B** - Security vulnerabilities, error handling improvements, and validation needs
17. **B** - Complete project structure, configs, tests, CI/CD, and monitoring setup
18. **B** - By analyzing the entire codebase and determining relevant files before making changes
19. **B** - Solutions may be less accurate or incomplete, requiring more manual review
20. **B** - It significantly minimizes manual debugging effort by autonomously fixing and revalidating
21. **B** - Compiling code, installing dependencies, and running tests
22. **B** - OpenAI Codex
23. **B** - Suitable build scripts and deployment scripts aligned with existing workflows
24. **B** - Increase manual review and provide clearer context
25. **B** - Agent Mode is an intelligent, proactive collaborator that adapts to developer workflow

## Summary

GitHub Copilot Agent Mode enhances the software development workflow from autonomously creating applications to intelligently refactoring and iterating on your codebase. Together with GitHub Codespaces and Visual Studio Code, Agent Mode uses your project's documentation, context, and insights to autonomously drive improvements, fix issues, and develop new features.

Key takeaways:
- Agent Mode functions as an autonomous peer programmer that handles complex, multi-step tasks
- It provides complete transparency and control over proposed changes
- The iterative draft-review-accept workflow accelerates development cycles
- Premium Request Units (PRUs) power advanced reasoning capabilities
- Self-healing capabilities minimize manual debugging effort
- Developer maintains full control with ability to review, adjust, or revert any changes

By integrating GitHub Copilot Agent Mode into development workflows, developers can significantly increase productivity while maintaining full control over their projects, reducing cognitive load and allowing focus on higher-level design and problem-solving.
