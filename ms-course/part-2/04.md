# Leveling Up Code Reviews and Pull Requests with GitHub Copilot

## Overview

Code reviews are vital for maintaining code quality and collaboration, but they often create bottlenecks. Developers juggle long review cycles, inconsistent feedback, and difficulty providing actionable suggestions—especially across multiple languages and frameworks. This module introduces how GitHub Copilot enhances code reviews by accelerating review cycles, catching issues, and enforcing best practices.

**Module Duration**: 35 minutes  
**Level**: Intermediate

## Learning Objectives

By the end of this module, you'll be able to:

- Explain how GitHub Copilot streamlines code reviews and pull requests
- Identify the key features Copilot adds to the review process
- Request and interpret Copilot reviews on GitHub.com and understand their limits
- Run Copilot reviews locally in your IDE and apply custom instructions
- Leverage Premium Request Units (PRUs) for deeper, context-rich analysis
- Automate Copilot reviews across repositories with rulesets and status checks
- Apply Copilot's suggestions responsibly, combining them with human judgment and testing

## Prerequisites

- A GitHub account
- GitHub Copilot enabled on your account (Copilot Pro, Copilot Pro+, Business, or Enterprise plan recommended for full code review features)
- Basic familiarity with pull requests and code reviews—creating a PR, leaving comments, and merging changes
- (Optional) A development environment such as Visual Studio Code or JetBrains IDEs if you plan to use Copilot reviews locally

## Introduction to Code Reviews with Copilot

GitHub Copilot helps resolve code review challenges by acting as a collaborative reviewer and assistant. It doesn't replace humans but works alongside them—catching issues, suggesting improvements, drafting summaries, and even auto-fixing vulnerabilities.

You can also customize Copilot with your own review guidelines using `.github/copilot-instructions.md`, so it looks for the same patterns and standards you care about as a human reviewer. This means Copilot not only accelerates reviews but also enforces your team's best practices consistently across repositories.

### Premium Request Units (PRUs)

Premium Request Units (PRUs) power Copilot's most advanced capabilities. Each time you ask Copilot to perform a premium-level task—such as reviewing an entire pull request, running in agent mode, or generating complex multi-step suggestions—it consumes a PRU. These premium requests give Copilot the additional processing power and context depth it needs to deliver richer reasoning, stronger best-practice checks, and more reliable outputs.

## What GitHub Copilot Adds to the Review Process

### Key Features of Copilot in Code Reviews

Copilot introduces several features designed to streamline reviews:

**PR Summaries**: Copilot can automatically draft pull request descriptions that include a clear summary of changes and a list of affected files. This ensures reviewers start with context, not guesswork.

**Security Fixes**: With Copilot code review integrated into GitHub Code Scanning, vulnerabilities are flagged across languages. For example, in JavaScript, Copilot can spot unsanitized input passed to `eval()` and comment:

> "eval() with user input can lead to code injection. Replace it with a safe parser like JSON.parse()."

It then offers an inline patch aligned with your repository's security guidelines.

**Line-by-Line Explanations**: Reviewers can highlight code and ask Copilot to explain functionality, helping them understand unfamiliar code quickly.

**Drafting Comments**: Copilot can generate review comments based on best practices or team guidelines, making feedback clear and actionable.

**Reviews in Your IDE**: In addition to working directly on GitHub.com, Copilot can also review code inside your IDE. This allows developers to catch and resolve issues before opening a pull request, speeding up the process and reducing rework.

### Understanding How PRUs Unlock Advanced Review Capabilities

PRUs power these advanced capabilities. For example, assigning Copilot as a PR reviewer uses a PRU each time it posts comments. When combined with custom `.github/copilot-instructions.md` files, PRU-powered reviews align with your team's rules, whether they focus on readability, security, or style.

**Example:**

Without Copilot: A PR might include vague comments from a reviewer like "Fix security issue here".

With Copilot + PRUs: The review becomes:

> "The use of exec() introduces a code injection vulnerability. Consider replacing it with subprocess.run() for safer command execution. Here's a suggested patch:"

And it provides the code fix inline.

### Five Ways Copilot Review Helps Developers

**1. Using Copilot Suggestions in Code Reviews**

When you're reviewing a pull request, you might spot areas that could be improved but not have the time to draft the perfect example yourself. Inside the pull request "Files changed" view, you can highlight a line or block of code and ask Copilot to suggest improvements or flag potential issues.

For example, while reviewing a Ruby file with repeated logic, you could highlight the relevant lines and ask:

> "Suggest a cleaner Ruby refactor for this repeated code."

Copilot will propose an updated version that follows common Ruby best practices.

**2. Reviewing Across Multiple Languages**

When you request a code review, Copilot can automatically highlight areas that don't follow best practices or team guidelines. Copilot will quickly generate improvements that align with the conventions of the language, enabling you to give stronger, more accurate review feedback even outside your primary area of expertise.

**3. Formatting Data for Pull Requests**

Pull requests are much clearer when they include well-formatted context such as metrics, screenshots, or test results. Copilot can act as a second set of eyes during code review, automatically flagging poorly formatted tables in a pull request description and proposing a cleaner version that aligns with your company's style guidelines.

**4. Writing Effective Pull Request Summaries**

Writing PR descriptions is often the last step in the process and can feel like a hurdle. From the PR description editor, you can use the Copilot icon to generate a draft summary or outline. Even if you make edits, having a well-structured starting point saves time and ensures reviewers have the information they need.

**5. Explaining and Reviewing Code**

Sometimes you may be unfamiliar with the code in a pull request. Instead of struggling through it, you can ask Copilot to explain the changes. Copilot can also run an initial review of your own PRs before you request feedback from teammates. This helps catch smaller issues, validates best practices, and gives you more confidence in the quality of your submission.

## Using Copilot as a Reviewer in GitHub.com

On GitHub.com, requesting a Copilot review is as simple as adding it from the Reviewers menu. Within seconds, Copilot generates a comment review—not an approval or rejection—so it never blocks merges but instead adds valuable context for human reviewers.

### How to Request a Code Review on GitHub.com

**Step 1**: Open or create a pull request

**Step 2**: Add Copilot as a reviewer - In the Reviewers menu, select Copilot

**Step 3**: Wait for the review to complete - Reviews typically finish in less than 30 seconds

**Step 4**: Review Copilot's comments - Scroll through the pull request to read Copilot's feedback

**Step 5**: Apply Copilot's suggested changes - When Copilot flags issues, you can commit fixes directly from the PR interface

**Example prompt:**

> "Suggest a fix for this review comment: Replace exec() with a safer function."

Copilot proposes a patch using `subprocess.run()`. The developer tests it locally, commits, and ensures tests pass.

PRUs make these fixes faster and smarter—enabling Copilot to analyze review comments alongside code context to propose high-quality solutions.

### Understanding the Limits

Copilot's role in reviews is advisory. It doesn't approve or reject pull requests, and its comments don't count toward required approvals. Use it to catch issues early, generate actionable suggestions, and speed up routine checks, but rely on human reviewers for architectural decisions, nuanced trade-offs, and final sign-off.

## Catching Issues Early and Automating Reviews

### Running Copilot Reviews Locally in Your IDE

In VS Code or JetBrains IDEs, you can request Copilot to review changes before committing. This lets you address style violations, security gaps, or best practice issues earlier—saving cycles in the review process.

To guide reviews, create a `.github/copilot-instructions.md` file with rules such as:

- "Focus on security and avoid unsafe string interpolation."
- "Ensure functions have docstrings explaining parameters and return types."

Copilot then applies these rules automatically to analyze larger diffs and provide context-rich insights that align with your repo's style.

**Use case**: A developer adds repetitive code in a TypeScript service. Copilot flags it and suggests extracting a helper function. Instead of waiting for peers to point it out, the developer fixes it before pushing the code—reducing review noise later.

### Creating Path-Specific Custom Instructions

You can use path-specific custom instructions to guide Copilot code review or the Copilot coding agent for specific files or folders.

**Step 1**: Create the instructions directory - In the root of your repository, add a folder named `.github/instructions`

**Step 2**: Add instruction files - Inside that folder, create one or more files ending in `.instructions.md` (e.g., `security.instructions.md`)

**Step 3**: Define the paths to apply to - At the top of each file, add a frontmatter block with an `applyTo` keyword using glob syntax

**Example - apply to Ruby models:**
```
applyTo: "app/models/**/*.rb"
```

**Example - apply to TypeScript files:**
```
applyTo: "**/*.ts,**/*.tsx"
```

**Step 4**: Write your custom guidance - Below the frontmatter, add your review guidance in plain language using Markdown

### Leveraging PRUs for Deeper Analysis in Your IDE

When you run Copilot reviews directly inside your IDE, you're not limited to lightweight checks. By allocating Premium Request Units (PRUs) to these local reviews, Copilot can tap into more advanced models that analyze larger diffs, apply your repository's custom instructions, and surface higher-quality suggestions before code ever reaches a pull request.

### Automating Reviews and Scaling with Rulesets

Manual reviews don't scale well in fast-moving teams. GitHub allows you to configure rulesets so Copilot is automatically assigned to all PRs targeting protected branches.

This creates a pipeline where:
- Copilot reviews for style and readability
- Code scanning flags vulnerabilities
- Tests validate functionality

Because each Copilot review uses PRUs, organizations should budget PRU consumption to match review volume and perform automated reviews at appropriate times in the development process.

### Automatic Reviews for Your Account

When you turn this feature on in your personal Copilot settings (Copilot Pro or Copilot Pro+ plan), every PR you open will automatically be reviewed.

**Steps:**
1. In the upper-right corner of any GitHub page, click your profile picture and select "Your Copilot"
2. Find the "Automatic Copilot code review" option
3. From the dropdown, select "Enabled"

### Automatic Reviews for a Repository

Repository admins can enforce automatic reviews by creating a branch ruleset.

**Steps:**
1. In the repository, click Settings
2. In the left sidebar, expand "Code and automation" and select "Rules → Rulesets"
3. Click "New ruleset", then choose "New branch ruleset"
4. Enter a name, set Enforcement status to "Active", and select target branches
5. Under "Branch rules", check "Require a pull request before merging"
6. In the expanded options, select "Request pull request review from Copilot"
7. Click "Create"

### Automatic Reviews Across an Organization

Organization owners can create rulesets that apply to selected repositories based on name patterns or inclusion/exclusion rules.

**Steps:**
1. Click your profile picture, then select "Your organizations"
2. Choose the organization, then go to Settings
3. In the sidebar, select "Repository → Rulesets"
4. Click "New ruleset → New branch ruleset"
5. Provide a ruleset name and set Enforcement status to "Active"
6. Add target repositories by specifying inclusion or exclusion patterns
7. Define target branches
8. Enable "Require a pull request before merging", then check "Request pull request review from Copilot"
9. Save by clicking "Create"

## Measuring Impact and Optimizing PRUs

### Understanding PRUs

Think of Premium Request Units (PRUs) as tokens that unlock Copilot's "extra gear." Routine, lightweight tasks often don't consume PRUs. But premium-level tasks do—like asking Copilot to review a 1,500-line change across multiple files, apply your `.github/copilot-instructions.md` file, and check for security and style issues.

**Example scenario:**

A developer pushes a massive refactor touching dozens of files. Copilot, assigned as a reviewer, uses PRUs to apply the repository's security and style guidelines to the entire change, flags several unsafe string interpolations, and even drafts Markdown comments explaining the issue.

### Why PRUs Matter for Teams

PRUs are what make Copilot truly scalable in high-volume environments. With them, you can:

- **Get deeper analysis**: Spot subtle vulnerabilities, duplicated logic, or style violations across large diffs before they reach production
- **Enforce consistency**: Apply the same security, readability, or style checks across every pull request automatically
- **Handle bursts of activity**: During busy release cycles, rely on PRU-powered reviews to keep quality steady while human reviewers handle complex design decisions

### Measuring the Impact of PRU-Powered Reviews

To understand the return on PRUs, track metrics such as:

- **PR lead time**: How quickly pull requests go from open to merged after adding Copilot reviews
- **Quality indicators**: Reduction in post-merge security or style issues flagged by other tools
- **Developer experience**: Feedback on whether Copilot makes reviews faster or clearer

**Example metric:**

Before using PRUs, large PRs took an average of three days to merge and frequently triggered style fixes after release. After enabling PRU-powered reviews, the same PRs merged in one day with far fewer follow-up commits.

### Optimizing PRU Usage

Managing PRUs ensures you're spending them where they add the most value:

- **Plan ahead**: Set alerts when you hit 75%, 90%, and 100% of your monthly PRU usage
- **Use PRUs strategically**: Reserve premium reviews for large or high-risk changes; rely on standard Copilot suggestions for simple edits
- **Refine your prompts**: Clean, specific requests reduce unnecessary retries and wasted PRUs
- **Scale up if needed**: If your team consistently maxes out PRUs, consider a higher-tier Copilot plan to support the workload

**Example scenario:**

A team notices that many PRUs are spent on trivial documentation changes. They update their workflow to use non-PRU requests for small edits and reserve PRU-powered reviews for code that affects production. As a result, their monthly PRU usage drops by 30% without losing quality.

## Assessment Questions

1. What is the primary benefit of using GitHub Copilot in code reviews?
2. What do PRUs stand for and what do they power?
3. What file is used to customize Copilot's review behavior?
4. Name three key features Copilot adds to the review process.
5. Can Copilot approve or reject pull requests?
6. Where can you run Copilot reviews besides GitHub.com?
7. What happens when you assign Copilot as a PR reviewer?
8. How long do Copilot reviews typically take to complete?
9. What is the purpose of path-specific custom instructions?
10. What glob syntax would you use to apply instructions to all TypeScript files?
11. How do PRUs enable deeper analysis in IDE reviews?
12. What is the benefit of automating Copilot reviews with rulesets?
13. Which Copilot plans support automatic code review for your account?
14. Who can enable automatic reviews for a repository?
15. What must be checked under "Branch rules" to enable automatic Copilot reviews?
16. How can organization owners apply automatic reviews across multiple repositories?
17. What is the first metric you should track to measure PRU impact?
18. What percentage thresholds should you set for PRU usage alerts?
19. How did one team reduce PRU usage by 30% in the example?
20. What should you do if your team consistently maxes out PRUs?
21. What security vulnerability can Copilot detect in JavaScript code using eval()?
22. What safer alternative does Copilot suggest instead of exec() in Python?
23. What happens when Copilot flags a poorly formatted table in a PR description?
24. Can you use Copilot to explain unfamiliar code in a pull request?
25. What is Copilot's role in the review process—advisory or authoritative?

## Answer Key

1. It accelerates review cycles, catches issues, and enforces best practices consistently
2. Premium Request Units; they power advanced review capabilities like analyzing entire PRs and applying custom instructions
3. `.github/copilot-instructions.md`
4. PR Summaries, Security Fixes, Line-by-Line Explanations, Drafting Comments, Reviews in Your IDE (any three)
5. No, it generates comment reviews only—it doesn't approve or reject PRs
6. In your IDE (VS Code or JetBrains IDEs)
7. It uses a PRU and posts review comments based on best practices and team guidelines
8. Typically less than 30 seconds
9. To guide Copilot code review for specific files or folders using targeted rules
10. `"**/*.ts,**/*.tsx"`
11. They allow Copilot to use advanced models that analyze larger diffs and apply custom instructions for higher-quality suggestions
12. It ensures every change gets reviewed consistently, even if human reviewers are delayed
13. Copilot Pro and Copilot Pro+
14. Repository admins
15. "Require a pull request before merging" and "Request pull request review from Copilot"
16. By creating rulesets with repository name patterns or inclusion/exclusion rules
17. PR lead time (how quickly PRs go from open to merged)
18. 75%, 90%, and 100%
19. They reserved PRU-powered reviews for production code and used non-PRU requests for documentation changes
20. Consider a higher-tier Copilot plan to support the workload
21. Code injection vulnerability from unsanitized user input
22. `subprocess.run()` for safer command execution
23. It proposes a cleaner version aligned with company style guidelines
24. Yes, you can ask Copilot to explain the changes
25. Advisory—it doesn't count toward required approvals and doesn't block merges

## Summary

Copilot is most effective when treated as a collaborator, not a replacement. Use it to accelerate routine checks and provide actionable suggestions, but rely on humans for architectural decisions and nuanced tradeoffs.

### Best Practices

- Run Copilot reviews in your IDE before pushing
- Use `.github/copilot-instructions.md` to align Copilot's feedback with team standards
- Treat Copilot's comments as accelerators, not mandates
- Always validate and test fixes before merging
- Continue to use your release CI/CD pipelines, scans, and other best practices alongside Copilot reviews

### Key Takeaways

- GitHub Copilot improves code reviews and PRs by catching issues, suggesting improvements, and enforcing best practices
- PRUs unlock premium-powered features that make Copilot an even stronger partner
- You can use Copilot as a reviewer on GitHub.com and in your IDE
- Automate reviews with rulesets and custom instructions for consistency at scale
- Measure impact through PR lead time, quality indicators, and developer experience
- Optimize PRU usage by planning ahead, using strategically, and refining prompts

With these practices, your team can transform code reviews from bottlenecks into collaborative, high-value moments—scaling expertise and delivering software faster while maintaining quality, security, and compliance standards.
